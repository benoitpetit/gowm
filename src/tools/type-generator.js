/**
 * GoWM Type Generator
 * Generates TypeScript type definitions from module.json metadata.
 * 
 * @version 1.1.1
 */

/**
 * Map module.json parameter types to TypeScript types
 * @param {string} type - module.json type
 * @returns {string} TypeScript type
 */
function mapType(type) {
    if (!type) return 'any';
    const map = {
        'string': 'string',
        'number': 'number',
        'boolean': 'boolean',
        'object': 'Record<string, any>',
        'array': 'any[]',
        'any': 'any',
        'void': 'void',
        'int': 'number',
        'float': 'number',
        'float64': 'number',
        'int64': 'number',
        'uint8array': 'Uint8Array',
        'Uint8Array': 'Uint8Array',
        'base64': 'string',
        'json': 'string',
        'xml': 'string',
    };
    return map[type] || 'any';
}

/**
 * Generate TypeScript interface definitions from module.json metadata.
 * @param {object} metadata - Parsed module.json content
 * @param {object} [options] - Generation options
 * @param {string} [options.interfaceName] - Custom interface name (default: derived from module name)
 * @param {boolean} [options.includeJSDoc=true] - Include JSDoc comments
 * @param {boolean} [options.exportDefault=false] - Export as default
 * @returns {string} TypeScript source code
 */
function generateTypes(metadata, options = {}) {
    if (!metadata || !metadata.name) {
        throw new Error('Invalid metadata: missing "name" field');
    }

    const includeJSDoc = options.includeJSDoc !== false;
    const exportDefault = options.exportDefault || false;

    // Derive interface name: "math-wasm" → "MathWasmBridge"
    const baseName = options.interfaceName || toPascalCase(metadata.name) + 'Bridge';
    const lines = [];

    // Header
    lines.push(`// Auto-generated by GoWM Type Generator`);
    lines.push(`// Source: ${metadata.name}@${metadata.version || 'unknown'}`);
    lines.push(`// Generated: ${new Date().toISOString().split('T')[0]}`);
    lines.push(`//`);
    lines.push(`// Do not edit manually — regenerate with: npx gowm types <repo> ${metadata.name}`);
    lines.push('');
    lines.push(`import { WasmBridge, LoadOptions } from 'gowm';`);
    lines.push('');

    // Generate result types for functions with known return patterns
    const resultTypes = new Map();
    if (metadata.functions) {
        for (const fn of metadata.functions) {
            if (fn.returnType && fn.returnType === 'object' && fn.example) {
                // Try to infer result shape from examples
                const typeName = toPascalCase(fn.name) + 'Result';
                resultTypes.set(fn.name, typeName);
            }
        }
    }

    // Main bridge interface with typed call overloads
    if (includeJSDoc) {
        lines.push(`/**`);
        lines.push(` * Typed bridge for ${metadata.name} module`);
        if (metadata.description) {
            lines.push(` * ${metadata.description}`);
        }
        lines.push(` */`);
    }
    lines.push(`${exportDefault ? 'export default' : 'export'} interface ${baseName} extends WasmBridge {`);

    if (metadata.functions) {
        for (const fn of metadata.functions) {
            // Skip system functions
            if (fn.name === 'getAvailableFunctions' || fn.name === 'setSilentMode') continue;

            if (includeJSDoc && fn.description) {
                lines.push(`    /** ${fn.description} */`);
            }

            const params = (fn.parameters || []).map(p => {
                const optional = p.optional ? '?' : '';
                const isVariadic = p.name && p.name.startsWith('...');
                if (isVariadic) {
                    const cleanName = p.name.replace('...', '');
                    return `...${cleanName}: ${mapType(p.type)}[]`;
                }
                return `${p.name}${optional}: ${mapType(p.type)}`;
            });

            const returnType = mapType(fn.returnType);
            const paramsStr = params.length > 0 ? ', ' + params.join(', ') : '';
            lines.push(`    call(func: '${fn.name}'${paramsStr}): ${returnType};`);
        }
    }

    lines.push('}');
    lines.push('');

    // Module options interface
    if (includeJSDoc) {
        lines.push(`/** Loading options for ${metadata.name} */`);
    }
    lines.push(`export interface ${toPascalCase(metadata.name)}Options extends LoadOptions {`);
    lines.push(`    name?: '${metadata.name}';`);
    lines.push('}');
    lines.push('');

    return lines.join('\n');
}

/**
 * Generate types from a GitHub repository by fetching module.json
 * @param {string} repoIdentifier - GitHub repo "owner/repo"
 * @param {string} modulePath - Path within repo (e.g. "math-wasm")
 * @param {object} [options] - Generation options
 * @returns {Promise<string>} TypeScript source code
 */
async function generateTypesFromGitHub(repoIdentifier, modulePath, options = {}) {
    const branch = options.branch || 'master';
    const parts = repoIdentifier.split('/');
    if (parts.length !== 2) {
        throw new Error(`Invalid repo format: "${repoIdentifier}". Expected "owner/repo".`);
    }
    const [owner, repo] = parts;
    const url = `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${modulePath}/module.json`;

    const fetch = globalThis.fetch || (await import('node-fetch')).default;
    const response = await fetch(url);
    if (!response.ok) {
        throw new Error(`Failed to fetch module.json from ${url}: ${response.status}`);
    }

    const metadata = await response.json();
    return generateTypes(metadata, options);
}

/**
 * Convert kebab-case or snake_case to PascalCase
 * @param {string} str
 * @returns {string}
 */
function toPascalCase(str) {
    return str
        .replace(/[-_]+/g, ' ')
        .replace(/\b\w/g, c => c.toUpperCase())
        .replace(/\s+/g, '');
}

module.exports = { generateTypes, generateTypesFromGitHub, mapType, toPascalCase };
